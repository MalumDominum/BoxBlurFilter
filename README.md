# Parallel Box Blur Filter
### Огляд
У цьому завдання ми застосуємо фільтр розмиття (box blur filter), який використовується в таких програмах, як Adobe® PhotoShop®, для розмиття зображень. В даному завданні фільтр - це алгоритм, який приймає вхідне зображення і певним чином перетворює його у вихідне зображення. Box blur filter видає зображення, на якому кожен піксель має середнє значення оточуючих пікселів від вихідного зображення. Box blur filter є прикладом проблеми легкої для паралелізації - щоб розділити його на паралельні завдання, не потрібно чи дуже мало зусиль. Кожен піксель вихідного зображення може бути обчислений незалежно від інших пікселів і паралельно.
Виконаємо завдання в чотири кроки. Спочатку ми реалізуємо ядро box blur filter, метод, який використовується для обчислення одного пікселя вихідного зображення. Потім ми реалізуємо дві версії розмиття паралельного вікна та виміряємо різницю в продуктивності. Нарешті, ми спробуємо наші реалізації розмиття паралельних вікон на реальних зображеннях, використовуючи ScalaShop - інструмент для обробки зображень, який вразить навіть людей Adobe® :)
### Попередні етапи
Перш ніж розпочати, нам потрібно висвітлити деякі основні типи даних та допоміжні методи. Ці утиліти вже реалізовані для цього завдання. По-перше, ми будемо використовувати тип RGBA для позначення значення пікселя зображення. Ми обмежимося 32-бітними зображеннями глибини пікселів, тому визначаємо RGBA рівним 32-бітному цілочисельному типу:
```scala
type RGBA = Int
```
Чому ми називаємо цей тип RGBA? Це пояснюється тим, що кожне значення пікселя складається з 4 компонентів - червоного, зеленого, синього та альфа, де альфа позначає величину прозорості у відповідному пікселі. Ці компоненти називаються каналами. Значення кожного каналу становить принаймні 0 і не більше 255.
Ми можемо вилучити червоний, зелений, синій та альфа-канал, використовуючи такі утилітні методи, які використовують маскування бітів та зміщення бітів:
```scala
/** Returns the red component. */
def red(c: RGBA): Int = (0xff000000 & c) >>> 24

/** Returns the green component. */
def green(c: RGBA): Int = (0x00ff0000 & c) >>> 16

/** Returns the blue component. */
def blue(c: RGBA): Int = (0x0000ff00 & c) >>> 8

/** Returns the alpha component. */
def alpha(c: RGBA): Int = (0x000000ff & c) >>> 0
```
Аналогічним чином, враховуючи значення чотирьох каналів, ми можемо отримати значення пікселя наступним чином:
```scala
/** Used to create an RGBA value from separate components. */
def rgba(r: Int, g: Int, b: Int, a: Int): RGBA = {
 (r << 24) | (g << 16) | (b << 8) | (a << 0)
}
```

Тепер, коли ми знаємо, як маніпулювати окремими пікселями, ми можемо визначити наш тип зображення Img:
```scala
/** Image is a two-dimensional matrix of pixel values. */
class Img(val width: Int, val height: Int, private val data: Array[RGBA]) {
 def this(w: Int, h: Int) = this(w, h, new Array(w * h))

 def apply(x: Int, y: Int): RGBA = data(y * width + x)

 def update(x: Int, y: Int, c: RGBA): Unit = data(y * width + x) = c
}
```
Зображення є двовимірною сутністю - для посилання на піксель у зображенні нам потрібно вказати компоненти x та y. З іншого боку, основна модель пам'яті є одновимірною - одне значення зміщення визначає позицію в масиві. Коли ми зберігаємо зображення в пам’яті, нам потрібно співвідношення між двомірною моделлю зображення та одновимірною моделлю пам’яті. Ми зробимо це, зберігаючи послідовні рядки зображення один за одним, як показано на наступному малюнку:


Таким чином, зміщення пікселя при координатах x і y дорівнює y * width + x, де width - це кількість пікселів в одному рядку. Хоча на практиці використовуються й інші відображення, ми обмежимось цим простим відображенням протягом усієї роботи.
Щоб гарантувати, що значення координат x та y обмежуються розмірами зображення, а саме шириною та висотою, іноді нам доводиться викликати метод clamp:
```scala
def clamp(v: Int, min: Int, max: Int): Int =???
```
Зверніть увагу на реалізацію цього методу, він повертає індекс, обмежений границями малюнка, а не значення кольору за цим індексом. 
Нарешті, ми використаємо конструкцію task для запуску паралельних обчислень. Кожне виклик task  повертає об'єкт, на якому ми можемо викликати метод join. Виклик методу join блокує виконання програми, поки паралельне обчислення не закінчиться. Нижче ми обчислюємо вираз 1 + 1 паралельно основній програмі:
```scala
val computation = task {
 val result = 1 + 1
 println("Done!")
 result
}
println("About to wait for some heavy calculation...")
computation.join()
```

Тепер у нас є все, що нам потрібно, щоб розпочати реалізацію фільтра.

### Ядро фільтра розмиття

У першій частині завдання ми реалізуємо метод ядра фільтра розмиття. Ядро - це метод, який обчислює отримане значення для одного пікселя. Метод kernel, як правило не потребує складних обчислень, тому немає необхідності робити його паралельним. Однак, як ми побачимо пізніше, ми можемо застосовувати один і той же метод ядра до різних пікселів паралельно.



Метод boxBlurKernel приймає вихідне зображення src, координати пікселя  x та y та радіус розмиття. Він повертає отримане середнє значення оточуючих пікселів. Ми обчислюємо середнє значення, розділяючи піксель на чотири канали, обчислюючи середнє значення кожного з каналів, і використовуючи чотири середні значення для отримання кінцевого значення пікселя. На попередньому малюнку параметр радіуса дорівнює 1, а середнє значення обчислюється з 9 пікселів.
Ви можете знайти його сигнатуру в об'єкті пакету:
```scala
/** Computes the blurred RGBA value of a single pixel of the input image. */
def boxBlurKernel(src: Img, x: Int, y: Int, radius: Int): RGBA = ???
```
Реалізуйте метод boxBlurKernel. Використовуйте два вкладені цикли while. Переконайтеся, що на пікселі по краях зображення впливають лише пікселі всередині зображення (підказка: використовуйте метод clamp з об’єкта пакету).

### Vertical Stripping Box Blur

Тепер ми можемо перейти до паралельного фільтру розмиття. Зауважте, що метод boxBlurKernel є відносно недорогим. Виконання boxBlurKernel може бути набагато швидшим, ніж запуск паралельного обчислення, тому наявність окремого паралельного обчислення для значення кожного пікселя було б занадто дорогим. З цієї причини ми хочемо об’єднати багато викликів boxBlurKernel і маємо меншу кількість паралельних завдань. Це іноді називають агломерацією, і вона присутня у багатьох реалізаціях паралельних алгоритмів.
Існує багато різних способів зробити агломерацію для box blur filter. Один - розділити зображення на фіксовану кількість однаково широких вертикальних смуг. Для кожної смужки ми починаємо паралельне завдання і чекаємо їх завершення. У межах кожної смуги ми проходимо пікселі, що йдуть зверху вниз, як показано на малюнку:



Ми починаємо з реалізації методу послідовного розмиття у вихідному файлі VerticalBoxBlur.scala, який приймає вихідне зображення src, цільове зображення dst, початкову (включену) та кінцеву (виключені) x координати (тобто індекси стовпців) смуги і радіус розмиття. Метод розмиття розмиває пікселі із зображення src і записує їх у зображення dst:
```scala
def blur(src: Img, dst: Img, from: Int, end: Int, radius: Int): Unit = ???
```
Реалізація розмиття повинна спиратися на раніше визначений boxBlurKernel. Потім реалізуйте метод parBlur, який ділить зображення на numTasks вертикальні смужки і виконує кожне завдання паралельно:
```scala
def parBlur(src: Img, dst: Img, numTasks: Int, radius: Int): Unit = ???
```
Використовуйте ranges Scala, щоб створити список точок розбиття (підказка: використовуйте метод by на ranges). Потім використовуйте комбінатори колекцій на списку точок розбиття, щоб створити список початкових і кінцевих кортежів, по одному для кожної смужки (підказка: використовуйте методи zip та tail). Нарешті, використовуйте конструкцію task, щоб запустити паралельну task для кожної смуги, а потім викликайте join для кожної task, щоб дочекатися його завершення.
Запустіть програму VerticalBoxBlur **за допомогою наступної команди sbt:**

**runMain scalashop.VerticalBoxBlurRunner**

Змініть кількість task і параметр радіуса. Як змінюється продуктивність?
Horizontal Stripping Box Blur
У цій частині вправи ми підберемо альтернативну агломерацію для алгоритму розмиття. Замість того, щоб ділити зображення на вертикальні смуги, ми поділимо його на горизонтальні смуги подібним чином:


Ми реалізуємо два методи, blur і parBlur, подібним чином, як і раніше:
```scala
def blur(src: Img, dst: Img, from: Int, end: Int, radius: Int): Unit = ???
def parBlur(src: Img, dst: Img, numTasks: Int, radius: Int): Unit = ???
```
Зверніть увагу, що аргументи from (включено) та end (виключено) цього разу позначають значення координати y (тобто індекси рядків), і що ми проходимо пікселі зліва направо в межах кожної смуги.
Тепер ви можете запустити програму HorizontalBoxBlur за допомогою:

**runMain scalashop.HorizontalBoxBlurRunner**

Якщо ви правильно застосували дві версії розмиття, слід зауважити, що горизонтальне розмиття відбувається трохи швидше. Це пов’язано з тим, що порядок обходу пікселів відвідує пікселі, які знаходяться ближче один до одного в пам’яті (пам’ятайте відображення між координатами пікселів та адресами пам'яті). Як результат, кожне ядро може повторно використовувати деякі пікселі, які воно отримало з пам'яті під час попереднього виклику boxBlurKernel. Ядра процесора витрачають менше часу на отримання пікселів з пам'яті та знижують тиск на шину пам'яті.

### ScalaShop

Тепер у нас є все необхідне для запуску ScalaShop:

**runMain scalashop.ScalaShop**
 
Змініть реалізацію розмиття, рівень паралельності та радіус розмиття та розгляньте вплив ваших змін на продуктивність.
 
Яка з двох реалізацій розмиття є швидшою?
Для яких значень параметра радіусу різниця є найбільш суттєвою? Чому?
Що якщо ми розділимо зображення на прямокутники? Це буде швидше?
 

### Тестування

В даному завданні для Вас не реалізовано тести, проте ви можете реалізувати їх самостійно. Ось декілька можливих варіантів, які допоможуть перевірити коректність вашої реалізації:

HorizontalBoxBlu / VerticalBoxBlur parBlur with 32 tasks should modify each pixel of the destination 32x32 image exactly once (використайте зручну вам кількість пікселів)
HorizontalBoxBlu / VerticalBoxBlur with radius 1 and 4 tasks should correctly blur the entire 3x3 image
HorizontalBoxBlu / VerticalBoxBlur parBlur  should not forget the last strip
boxBlurKernel should return the correct value on an interior pixel of a 3x4 image with radius 1  (використайте зручну вам кількість пікселів та радіус)
boxBlurKernel should correctly handle radius 0
boxBlurKernel should compute the averages of red, blue, green and alpha channels separately

### Індивідуальне завдання 
Для індивідуального завдання напишіть часткову функцію (Partial function)  як реалізацію інтерфейсу PartialFunction. Виконайте паралельне обчислення  заданої функції на проміжку x Є [-250, 250], розбиваючи його на константну кількість проміжків, або за допомогою рекурсії. 
Для паралельної реалізації використайте task, parallel collection, future.